# -*- coding: utf-8 -*-
"""
Created on Thu May 29 11:29:32 2014

@author: chiaracasotto
"""
import numpy as np
import scipy.stats as stat
pi = 3.141592653589793

def simplified_bilinear(T, Gamma, dcroof, SPO, bUthd, g, MC):
    
    if T<0.15: print 'error: T must be larger than 0.15sec'
    if T>3: print 'T>3 is not advised, but let us proceed'
    # Step 1: Ductility level mu for each Limit State
    dy, du = SPO[0],SPO[-1]
    dcroof[dcroof>du] = du
    mcroof = np.divide(dcroof,dy)
    print "mu(LS) = ", mcroof
        
    Say=4*np.power(pi,2)*dy/(g*Gamma*np.power(T,2));    
    c = np.multiply(79.12,np.power(T,1.98))
    R50 = 0.425*(1-c+np.sqrt(np.power(c,2)+c*2*(2*mcroof-1)+1))  
    if R50>6: print 'warning: R > 6 not advised, proceeding anyway'
   
# Monte Carlo simulation
    if bUthd.any>0 and MC>0:
        st = (1./(2.*MC))
        en = (1.-(1./(2.*MC)))
        xp = np.linspace(st,en,MC)
        musample = []
        for i in range(0,len(mcroof)):
            if bUthd[i]>0 and MC>0:
                musample.append(stat.lognorm.ppf(xp,bUthd[i],loc=0,scale=mcroof[i]))
                musample[i][musample[i]>mcroof[-1]]=mcroof[-1]
            else:
                musample.append(np.repeat(mcroof[i],MC))

        Nr=50;
        R = np.array([np.insert(np.linspace(1,2*ele,Nr),0,0) for ele in R50])
        #Define constant relative strength inelastic displacement ratio Cr    
        CR50i = 1 + np.divide(R-1,(79.12*np.power(T,1.98)));
        bCR50i=1.957*(1/5.876+1/(11.749*(T+0.1)))*(1-np.exp(-0.739*(R-1)));
        mu50=R*CR50i;
        mu16=mu50*np.exp(-bCR50i);
        mu84=mu50*np.exp(bCR50i);
        x=[mu16, mu50, mu84];
        
        Sai = []
        for i in range(0,len(mcroof)):
            Sai.append([])
        rMC, SaT50, bTSa, Sa = [],[],[],[]
        
        # Estimate R-values of Sa50 and bRSa that correspond to mlim samples.    
        for i in range(0,len(mcroof)):
            Sa.append(np.array([]))
            SaT50.append([])
            bTSa.append([])
            rMC.append([np.interp(musample[i],ele,R[i]) for ele in x])
            if bUthd[i]>0:
                allSa50 = [ele*Say for ele in rMC[1][i]]
                allbSa50 = (np.log(rMC[0][i])-np.log(rMC[2][i]))/2
                for j in range(0,MC):
                        if allbSa50[j]>0:
                            realisation = stat.lognorm.ppf(xp,allbSa50[j],loc=0,scale=allSa50[j])
                        else:
                            realisation = np.repeat(allSa50[j],MC)
                        Sai[i].append(realisation)
        
        for i in range(0,len(mcroof)):
            if len(Sai[i])>0:
                for j in range(1,len(Sai[i])):
                    Sai[i][j] = np.concatenate((Sai[i][j-1],Sai[i][j]))
                Sa[i] = Sai[i][-1]
                SaT50[i] = np.median(Sa[i])
                bTSa[i] = np.std(np.log(Sa[i]))
            else:
                R = np.maximum(R50[i],1.00001)
                Cr50 = 1+np.divide(R-1,c)           
                SaT50[i] = np.divide(np.power(2*pi/T,2),g*Gamma*Cr50)*dcroof 
                b = 1+np.divide(np.log(Cr50),np.log(R))
                sigmalnd = 1.957*(1/5.876+1/(11.749*(T+0.1)))*(1-np.exp(-0.73*(R-1)))
                bTSa[i] = sigmalnd/b
                
# No Montecarlo            
    else:        
        R = np.array([np.maximum(ele,1.00001) for ele in R50])
        Cr50 = 1+np.divide(R-1,c)           
        # Estimate Sa50 (median IM per Limit State) in m/s^2
        SaT50 = np.divide(np.power(2*pi/T,2),g*Gamma*Cr50)*dcroof 
        # Estimate b
        b = 1+np.divide(np.log(Cr50),np.log(R))
        # Estimate dispersion of theta demand
        sigmalnd = 1.957*(1/5.876+1/(11.749*(T+0.1)))*(1-np.exp(-0.73*(R-1)))
        bthd = sigmalnd
        bTSa = 1/b*np.sqrt(np.power(bthd,2)+np.power(bUthd,2))
    
    print "median IM = ", SaT50
    print "total dispersion = ", bTSa
    return [SaT50, bTSa]