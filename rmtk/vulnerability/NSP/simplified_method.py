# -*- coding: utf-8 -*-
# <nbformat>3.0</nbformat>

# <codecell>

"""
Created on Thu May 29 11:29:32 2014

@author: chiaracasotto
"""
import numpy as np
import os
import scipy.stats as stat
pi = 3.141592653589793

def simplified_bilinear(T, Gamma, drlim, SPO, bUthd, g, MC):
    
    if T<0.15:
        print 'error: T must be larger than 0.15sec'
        os._exit(1)
    if T>3: print 'T>3 is not advised, but let us proceed'

    dry, du = SPO[0],SPO[-2]
    drlim, bUthd = np.array(drlim),np.array(bUthd)
    drlim[drlim>du] = du
    # Ductility level mu for each Limit State
    mlim = np.divide(drlim,dry)
    print "mu(LS) = ", mlim
        
    Say=4*np.power(pi,2)*dry/(g*Gamma*np.power(T,2));    
    c = np.multiply(79.12,np.power(T,1.98))
    R50 = 0.5*(1-c+np.sqrt(np.power(c,2)+c*2*(2*mlim-1)+1))
    if R50.any>6: print 'warning: R > 6 not advised, proceeding anyway'
   
    if bUthd.any>0 and MC>0:
        # Monte Carlo simulation
        st = (1./(2.*MC))
        en = (1.-(1./(2.*MC)))
        xp = np.linspace(st,en,MC)
        musample = []
        for i in range(0,len(mlim)):
            if bUthd[i]>0 and MC>0:
                musample.append(stat.lognorm.ppf(xp,bUthd[i],loc=0,scale=mlim[i]))
                musample[i][musample[i]>mlim[-1]]=mlim[-1]
            else:
                musample.append(np.repeat(mlim[i],MC))
        Nr=10;
        R = np.array([np.insert(np.linspace(1,2*ele,Nr),0,0) for ele in R50])
        #Define constant relative strength inelastic displacement ratio Cr    
        CR50i = 1 + np.divide(R-1,(79.12*np.power(T,1.98)));
        bCR50i=1.957*(1/5.876+1/(11.749*(T+0.1)))*(1-np.exp(-0.739*(R-1)));
        mu50=R*CR50i;
        mu16=mu50*np.exp(-bCR50i);
        mu84=mu50*np.exp(bCR50i);
        x=[mu16, mu50, mu84];
        
        Sai = []
        for i in range(0,len(mlim)):
            Sai.append([])
        rMC, SaT50, bTSa, Sa = [],[],[],[]
        
        # Estimate R-values of Sa50 and bRSa that correspond to mlim samples.    
        for i in range(0,len(mlim)):
            Sa.append(np.array([]))
            SaT50.append([])
            bTSa.append([])
            rMC.append([np.interp(musample[i],ele[i],R[i]) for ele in x])
            if bUthd[i]>0:
                allSa50 = [ele*Say for ele in rMC[i][1]]
                allbSa50 = (np.log(rMC[i][0])-np.log(rMC[i][2]))/2
                for j in range(0,MC):
                    # for each potential (equiprobable) sample of mlim, get a sample of Sa-values
                    # as if we actually had N separate IDA curves, distributed according to the Sa50 and bSa50 values extracted above.
                    # In other words,generate N Sa-capacities for N different mlim realizations.
                        if allbSa50[j]>0:
                            realisation = stat.lognorm.ppf(xp,allbSa50[j],loc=0,scale=allSa50[j])
                        else:
                            realisation = np.repeat(allSa50[j],MC)
                        Sai[i].append(realisation)
        
        for i in range(0,len(mlim)):
            # Find median of sampled Sa-values for those drlim with bUthd>0, otherwise got to basic RGM method
            if len(Sai[i])>0:
                for j in range(1,len(Sai[i])):
                    Sai[i][j] = np.concatenate((Sai[i][j-1],Sai[i][j]))
                Sa[i] = Sai[i][-1]
                
                SaT50[i] = np.median(Sa[i])
                bTSa[i] = np.std(np.log(Sa[i]))
            else:
                R = np.maximum(0.85*R50[i],1.00001)
                Cr50 = 1+np.divide(R-1,c)
                b = 1+np.divide(np.log(Cr50),np.log(R))
                sigmalnd = 1.957*(1/5.876+1/(11.749*(T+0.1)))*(1-np.exp(-0.73*(R-1)))

                SaT50[i] = np.divide(np.power(2*pi/T,2),g*Gamma*Cr50)*drlim[i]
                bTSa[i] = sigmalnd/b
                
# No Montecarlo MC=0, simplified method to account for limit state uncertainty           
    else:        
        R = np.array([np.maximum(0.85*ele,1.00001) for ele in R50])
        Cr50 = 1+np.divide(R-1,c)           
        sigmalnd = 1.957*(1/5.876+1/(11.749*(T+0.1)))*(1-np.exp(-0.73*(R-1)))
        bthd = sigmalnd
        b = 1+np.divide(np.log(Cr50),np.log(R))

        SaT50 = np.divide(np.power(2*pi/T,2),g*Gamma*Cr50)*drlim
        bTSa = 1/b*np.sqrt(np.power(bthd,2)+np.power(bUthd,2))
    
    print "median IM = ", SaT50
    print "total dispersion = ", bTSa
    return [SaT50, bTSa]

