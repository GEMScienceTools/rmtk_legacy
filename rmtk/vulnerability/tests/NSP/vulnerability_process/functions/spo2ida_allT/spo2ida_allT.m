function [spoc,idac,cap]=spo2ida_allT(mc,a,ac,r,mf,T,pw,plotflag,only50,...
				      filletstyle,N,linew,fontsize)
%------------------------------------------------------
% A vary general routine aimed at moving from an SPo to an IDA for
% SDOF systems. Input for the moment is event-drifts and corresponding
% slopes on SPO. Later we should make this a bit more general (i.e
% input just points on SPO and detect automatically if negative or
% positive slope is happening, then apply rules. Here we assume you 
% approximate your backbone with linear segments.. 
% 
% 
% INPUT 
%  mc      : mu of end of hardening slope
%  a       : hardening slope in [0,1]
%  ac      : negative (capping) slope in [0.02, 4]
%  r       : Residual plateau height, a fraction of Fy
%  mf      : fracturing mu (end of SPO)
%  T       : period (sec)
%  pw      : pinching model weight.
% plotflag : if non-zero, plot the SPO plus 3 fractile IDA curves, 
%             otherwise not. If it is a 4-component vector, each
%             element corresponds to one of the following curves:
%             SPO, 16%,50%,84%.
%             Also, in all cases use figure(plotflag(i)) for the
%             plotting of i-th line (e.g., plotflag==[2,0,2,0], 
%             plots the SPO and the 50%-IDA in figure 2.
% only50   : if this flag is 1, then only the 50% line is modelled
%            accurately while the rest are plotted assuming a fixed
%            Coeff.of.Variation at each R-level.
%  N       : number of points per segment. For a full SPO (pXXmXXrXX)
%             we have 3 segments???
% linew    : line width for plots
% fontsize : fontsize used for labels, graphs etc. 
% OUTPUT
%  spoc.m, spoc.r : The SPO curve points in normalized m,f coords
%  idac(1:3).m, idac(1:3).r : same as above for the IDA. The three
%                             arrays are the 16,50,84 curves (demand-wise) 
%  cap.m,  cap.r  : coords of flatline capacity point on IDA
%-------------------------------------------------------
%
% This is a mirror routine of my Excel spreadsheet 
%  "Stick1tall - SPO to IDA model.xls". It is simply done into Matlab.
% hopefully as my model evolves, they should be kept compatible!
% CAREFUL !!!
% OLD version: spo2ida_2.m, only good for moderate periods and mc around 2-4. 
% Still, pretty good for ISO work!
% NEW version: still optimized for moderate periods (around 1sec)
% but it is pretty damned good. For one thing, It shows much better
% behavior and avoids the "badly-defined-Req" problem in the
% previous version. Corner filleting works beautifully, and all in
% all, I believe that this baby is a piece of art!
%
% IDEA : for improvement, must add a subroutine to remove all
% identical points, i.e., points that have BOTH X,Y the same. These
% get created sometimes for rXX.


% April 15th, 2002
%   fixed an error where slope_mXXend became Inf.
% April 26th, 2002
%   1)restricted a in [0,0.9] and r in [0,0.95], to avoid
%     extrapolating the fits.
%   2) pw=1 is the default now.
% November 11th, 2006
%   Added a note about a possible inconsistency in line 160.


if nargin<13, fontsize=11; end
if nargin<12, linew=2; end
if nargin<11, N=10; end
if nargin<10, filletstyle=3; end
if nargin<9, only50=0; end
if nargin<8, plotflag=[0,0,0,0]; 
elseif length(plotflag)==1, plotflag=repmat(plotflag,1,4); end
if nargin<7, pw=1; end
if nargin<6, error('need a full SPO definition'); end

% Always make sure ac is positive first!!
ac=abs(ac);

% check the parameters
if mc<1 | mc>9, error('We must have "mc" in [1,9]'),end
if a<0 | a>0.90, error('We must have "a" in [0,0.90]'),end
if ac<0.02 | ac>4, error('We must have "ac" in [0.02,4]'), end
if r<0 | r>0.95, error('We must have "r" in [0,0.95]'), end
if mf<1, error('We must have "mf" > 1'), end
if T<0.1 | T>4, error('We must have "T" in [0.1sec,4sec]'), end


% compute and plot the SPO curve.
[spoc]=spo2ida_spo(mc,a,ac,r,mf,plotflag(1),linew,fontsize);

% set the elastic part
idac(1).m=[0;1];idac(1).r=[0;1];
idac(2)=idac(1);
idac(3)=idac(1);

%keyboard
[pXX,mXX,rXX]=regions2model(a, mc, ac, r, mf);

mr=get_mr(a,ac,mc,r);
meq=get_meq(a,ac,mc);
mend=get_mend(a,ac,mc);
req=get_req(a,mc,r);
mpeak=get_mpeak(a,ac,mc); 


% Now if mf is really small it may influence some of the above
% since mc denotes end of pXX fitting, reduce it if mf is smaller
mc = min(mc,mf);
% Similarly, since mr denotes the end of mXX region, if mf is
% smaller, reduce it.
mr = min(mr,mf);


if pXX
  % set the pXX part. Allow ductilities 
  % up to the minimum of mc,mf
  [idac,Rmc,slmc]=model_pXX(idac,a,mc,T,pw,only50,N);
else
  % This is not a good idea. 
  Rmc=[1,1,1];
  slmc=[1,1,1];
end

if mXX
  % set the mXX part
  [idac]=model_mXX(idac,a,ac,mc,T,pw,mr,meq,mend,mpeak,Rmc,slmc,only50,...
		   filletstyle,N);
end

if rXX
  % set the mXX part
  [idac]=model_rXX(idac,a,ac,mc,mr,mf,r,req,T,pw,only50,filletstyle,N);
end

% should we have cases of no capacity? Say when ac=0 or mf=inf.


for i=1:3
  % pick maximum attainable R-value
  cap(i).r = max(idac(i).r);
  % pick the minimum ductility that can cause the highest R-value.
  cap(i).m = idac(i).m(min(find(idac(i).r==cap(i).r)));
  
  % add a flatline at fracture
  idac(i).r(end+1:end+2)=idac(i).r(end);
  idac(i).m(end+1:end+2)=[mf,mf+2];
  
  % IDEA : Remove duplicate points, i.e., points having same R,mu.
  % BAh, do it easier. Since R is sorted by definition, just iterate
  % through R. If R(i) and R(i-1) are the same and also mu(i),
  % mu(i-1) then store this "i" in indy. Remove all indy from R,m in
  % the end.
  
  % this will find any consecutive points that have different R or mu.
  indy=find(diff(idac(i).r)~=0 | diff(idac(i).m)~=0);
  % But the index to "diff" results is actually shifted by 1. So
  % make indy point to the original array, i.e. make it point to
  % unique mu,R points!!
  indy=[1;indy+1];
  
  % NOTE: 12/Nov/2006: I am not sure if the above works. Still, I have no
  % reason to change it. It seems that this should drop the flatline points
  % where we have the same R for two points, but in fact it doesn't due to
  % the "indy+1" trick above. For cases though where mf cuts everything and
  % only leaves a pXX part, points that are so close that they are almost
  % duplicates do appear at the start of the flatline.
  
  idac(i).r=idac(i).r(indy);
  idac(i).m=idac(i).m(indy);
end


%for i=1:3
%  indy=[1];
%  for j=2:length(idac(i).r)
%    if idac(i).r(j)~=idac(i).r(j-1) |  idac(i).m(j)~=idac(i).m(j-1)
%      indy=[indy,j];
%    end
%  end
%  idac(i).r=idac(i).r(indy);
%  idac(i).m=idac(i).m(indy);
%end  

spo2ida_plotIDA(idac,cap,a,ac,mc,r,plotflag(2:4),linew,fontsize);



 




%____________________________________________
% Fit pXX
%____________________________________________

function [idac,Rmc,slmc]=model_pXX(idac,a,mc,T,pw,only50,N)
% A companion function for spo2ida_modT. Fully calculates the pXX part.
% 

% the full model for any of the three fractiles is:
% lm = b0*lR + b1*lR^2 (1)
% or  mu = exp ( b0*logR + b1*logR^2)
%   b0=P4(a)
%   b1=P4(a)

% to find the R at mu=mc, we need to solve (1)
%  NOTE : mc>1 so log(mc)>0 always
%
% b1*logR^2 + b0*logR - log(mc) = 0
%   Diakrinousa = sqrt(b0^2 + 4*b1*log(mc)) > 0 (always)
%    logR(1) = ( -b0 + sqrt(Diakr) ) / 4*b1 
%    logR(2) = ( -b0 - sqrt(Diakr) ) / 4*b1
% so just pick the root that is greater than one.

%keyboard

if only50
   error('not ready yet')
else
   % parameters are always mu-independent. That's how we fit them
   [b0,b1]=spo2ida_get_ab_pXXtXX(a,T,pw);
   %the influence of period or the hysteresis model stops here!
   
   % calculate the "end-of-hardening-R" and the corresponding local
   % tangent slope.
   
   
   % BIG PROBLEM : The proposed coefs for b0,b1 are in trouble for
   % a>=0.8. The reason is that the fit for the 84% produces a
   % negative b1 (b1 is very close to zero there. MUST GET A GOOD FIX.
   
   [Rmc,slmc] = spo2ida_get_Rmc(mc,b0,b1);
   for i=1:3
     % the hardening part ends at m==mc
     % compute the R-values. Note that "1" is included though it
     % should not.
     RpXX=linspace(1,Rmc(i),N+1);
     % try not to repeat the end of the last segment (i.e. remove "1")!
     RpXX=RpXX(2:end)';

     % method 1: keep lower part of mXX and multiply by local Rmc
     % slope, if it is greater than one
     idac(i).r=[idac(i).r ; RpXX];
     idac(i).m=[idac(i).m ; ...
	exp(b0(i)*log(RpXX) + b1(i)*log(RpXX).^2)];
   end 
end   



%____________________________________________
% Fit mXX
%____________________________________________

function [idac]=model_mXX(idac,a,ac,mc,T,pw,mr,meq,mend,mpeak,...
			  Rmc,slmc,only50,filletstyle,N)
% A companion function for spo2ida_modT. Fully calculates the pXX part.
% 

%keyboard
if only50
  error('not ready yet')
else
  % parameters are always mu-independent. That's how we fit them
  
 
  % Instead of "mc" use "meq" to simulate pXXmXXcXX as p0mXXcYY.
  % similarly use Rmc_p0 at mc == meq.
  %[Rcap,Rcap_mXX]=spo2ida_get_Rcap_p0mXXcXX(ac,meq);
  
  % even better, use the improved version!!
  [Rcap,Rcap_mXX]=spo2ida_get_Rcap_pXXmXXcXXtXX(a,ac,T,meq,mpeak,Rmc,pw);
  
  % I used to use the dedicated fit. But this was fitted only for
  % the modT. For the allt I prefer to use the b0 from the p0tXX
  % fit. It seems to be just fine!
  [b0,b1]=spo2ida_get_ab_pXXtXX(0,T,pw);
  %[b0,b1]=spo2ida_get_ab_mXX(ac);
   for i=1:3
     % the softening part starts at m=mc and ends at m==mr
     % compute the R-values. Note that "mc" is included though it
     % should not.
     %keyboard
     switch filletstyle
      case {0,1,2} 
       % don't do any cute tricks. Just extend the pXX linearly
       % following the final slmc slope.
       RmXX=linspace(Rmc(i),Rcap(i),N+1);
       % try not to repeat the end of the last segment
       RmXX=RmXX(2:end)';
       idac(i).r=[idac(i).r ; RmXX];
       idac(i).m=[idac(i).m ; mc+(RmXX-Rmc(i))*slmc(i)];
       % method 1: include lower portion of mXX
       
       % maybe also multiply the ductilites by the local slope at Rmc. 
       %  idac(i).m=[idac(i).m ; ...
       %  max(slmc(i),1)*mc*exp(b0(i)*log(RmXX/Rmc(i)) +...
       % b1(i)*log(RmXX/Rmc(i)).^2)];
       % since our fits aren't really powerful there, simply increase
       
       % method 2: continue with pXX as if mXX never happened
       
       %[b0,b1]=spo2ida_get_ab_pXX(a);
       %idac(i).m=[idac(i).m ; ...
       %		exp(b0(i)*log(RmXX) + b1(i)*log(RmXX).^2)];
       
       
       % method 3: use later portion of mXX.
       %RmXX = linspace(Rcap_mXX(i)-(Rcap(i)-Rmc(i)),Rcap_mXX(i),N)';
       %idac(i).m=[idac(i).m ;...
       %		mc-1+exp(b0(i)*log(RmXX) + b1(i)*log(RmXX).^2)];
       
       % method 4: fillet with a single cubic polynomial (spline)
     
       % RmXX is designed to go up to Rcap. This may mean that
       % ductilities higher than mr may appear (up to mend is where
       % we fit the spline). How to fix this?? maybe fit the other
       % way.
       
      case 3,
       % use a repeated midpoint insertion and a control polygon
       % with spcrv to get the desired filleting.
       % This one is quaranteed to be
       % convexity-preserving and it is totally easy to code!
       % the trick is how to prescribe the control polygon.
       % See Farin, pg. 152.
       
       % Improvement: If all(slmc)==1 (pure mXX) then use b0 !!
       % this makes a big difference in making the pure mXX look
       % better. This b0 comes from p0tXX actually, no dedicated
       % fit exists.
       
       if all(slmc==1), slmc=b0; end;
       
       %keyboard
 
       
       % intersection of flatline and the tangent at end of pXX
       %xi=(Rcap(i)-Rmc(i))*slmc(i) + mc;
       xi=(log(Rcap(i))-log(Rmc(i)))*slmc(i) + log(mc);
       
       %cp = [2*mc-xi , 2*Rmc(i)-Rcap(i)
       %      xi    ,  Rcap(i) 
       %     2*mend-xi, Rcap(i)];
       cp = [2*log(mc)-xi , 2*log(Rmc(i))-log(Rcap(i))
	     xi    ,  log(Rcap(i)) 
	     2*log(mend)-xi, log(Rcap(i))];
       
       
       % if you use k=2 instead of 3, you will get the controlling
       % polygon. If you use higher k's then the curve no longer
       % touches the controlling polygon. whit k=2 you get same
       % results as with "case 0" above.
       k=3;
       newc =  spcrv(cp',k,round(1.5*N));
       
       newc=exp(newc);
       
       indy = find(newc(1,:)>mc & newc(1,:)<=mr);  
       
       % Possible problem: If mr very close to mc, sometimes we
       % will get an empty "indy". What to do then? Maybe increase N?
       % especially if mc=1 and r=0.99, tough baby!
       
       % add a "final point" right on mr. The filleting will
       % never do that by default, so make sure it happens!
       % this is especially critical if the real mr > mf, so we are
       % supplied a mr==mf here. So capacity really depends on us
       % providing this point.
       m_rXX = mr; 
       %keyboard;
       if isempty(indy)
	 % then probably mc slightly less than mr (could be just
	 % round-off error sometimes). Then just interpolate
	 % between the closest values surrounding "mc" (or "mr" 
	 % they are actually the same values since mc,mr are so close).
	 i1=max(find(newc(1,:)<=mc));
	 i2=i1+1;
       else
	 if indy(end)==length(newc(1,:))
	   % a linear extrapolation. Just so that you get a point
	   % right on the "mf" and capacity gets displayed
	   % correctly. Ahhh, finesse!!
	   i1=indy(end-1);
	   i2=indy(end);
	 else
	   % why extrapolate? Better to interpolate between indy(end)
	   % and the indy(end)+1 point (if it has been calculated).
	   i1=indy(end);
	   i2=indy(end)+1;
	 end 
       end
       R_rXX = newc(2,i2)+(newc(2,i2)-newc(2,i1))/...
	       (newc(1,i2)-newc(1,i1))*(mr-newc(1,i2));
       
       idac(i).m=[idac(i).m ; newc(1,indy)' ; m_rXX];
       idac(i).r=[idac(i).r ; newc(2,indy)' ; R_rXX];
	
       % the results are truly excellent.
     end 
   end   
end





%____________________________________________
% Fit rXX
%____________________________________________

function [idac]=model_rXX(idac,a,ac,mc,mr,mf,r,req,T,pw,only50,filletstyle,N)
% A companion function for spo2ida_modT. Fully calculates the rXX part.
% 
% mu = b0* R^b1




if only50
   error('not ready yet')
else
   % parameters are always mu-independent. That's how we fit them.
   [b0,b1]=spo2ida_get_ab_mXXrXXtXX(ac,req,T,pw);
  
   for i=1:3  
     Rmr(i) = idac(i).r(end);
     % if intersection of rXX "secant" with flatline is earlier
     % than mr, calculate only points beyond mr. This situation
     % should be extremely rare, unless r very close to 1. Also
     % notice that if mi > mf, then rXX is not present in THIS
     % fractile. This is a very usual situation for 84%-line.
     real_mi(i)=max( exp( b0(i) + log(Rmr(i))*b1(i)) , mr);
     % We will still use "real_mi" for our spline filleting, so
     % that the filleting will be independent of "mf".
     mi(i) = min( mf, real_mi(i));
     switch filletstyle
      case 0, 
       %keyboard
       m_rXX = linspace(mi(i),mf,N+1);
       % the residual part starts at mr and ends at m==mf
       m_rXX = m_rXX';
       if mi(i)<mf
	 % method 1: Don't do anything fancy, just extend the
	 % "flatline" that almost got through at mr (this will be at
	 % a height slightly less than the flatline that would have
	 % appeared without the rXX) all the way to the intersection
	 % with  the  "secant" of rXX. 
	 R_rXX = exp((log(m_rXX)-b0(i))/b1(i));
       else 
	 % mf has chopped us off before the secant can manifest itself
	 R_rXX = repmat(Rmr(i),size(m_rXX));
       end
       idac(i).r=[idac(i).r ; R_rXX];
       idac(i).m=[idac(i).m ; m_rXX];
      case {2,3},
     
       % use a repeated midpoint insertion and a control polygon
       % with spcrv to get the desired filleting.
       % This one is quaranteed to be
       % convexity-preserving and it is totally easy to code!
       % the trick is how to prescribe the control polygon.
       % See Farin, pg. 152.
       
       % QUESTION : At this point, I am using a constant 2*mi as
       % the point up to where the spline filleting is done. The
       % rest is purely the "secant". Maybe I should change the
       % limit as max(4*mi,mf), but then the filleting would be
       % dependent on "mf". This would be bad.
       % use real_mi, so that if mf is really small, filleting is
       % NOT mf-dependent.
       
       % NEW Method, to help for large "r's".
       % Instead of simulating a flattening right at the start of
       % rXX, just 
       %keyboard
       if log(idac(i).r(end))-log(idac(i).r(end-1))~=0
	 
	 slope_mXXend = (log(idac(i).m(end))-log(idac(i).m(end-1)))/...
	     (log(idac(i).r(end))-log(idac(i).r(end-1)));
	 if slope_mXXend == b1(i)
	   % if this causes the secant and the tangent to intercept
	   % lower than Rmr, the next "if" will fix it.
	   % actually I don't expect this piece of code to ever need
	   % to run. It will be a wild case indeed!
	   slope_mXXend = b1(i) + 0.05;
	 end
       
	 int_mXXend = log(mr) - slope_mXXend * log(Rmr(i));
	 
	 lRmi = (int_mXXend-b0(i))/(b1(i)-slope_mXXend);
       else
	 % The end of the mXX is indeed flat! so the secant and the 
         % flat, intersect at the Rmr height! No need for fancy
         % interpolation or intersection searching!
	 lRmi = log(Rmr(i));
       end
       
       
       
       % Prevent pathologies of the fitting process that can cause
       % the secant and the tangent to meet at Rmi < Rmr. There are
       % two such cases. Also, sometimes the tangent is parallel to
       % the secant. Improbable but keep it in mind.
       
       if lRmi < log(Rmr(i))
	 % This may happen for very large r-values.
	 % The two lines are intersecting lower that Rmr, or they
         % are parallel
	 if b1(i)>=slope_mXXend
	   % secant is softer and lower than the tangent. 
	   % "soften" the tangent to
	   % reach the secant.
	   slope_mXXend = b1(i) + 0.05;
	 else
	   % "secant" is harder and above the tangent. "Harden" the
           % tangent to reach the secant.
	   slope_mXXend = b1(i) - 0.05;
	 end   
	 int_mXXend = log(mr) - slope_mXXend * log(Rmr(i));
	 lRmi = (int_mXXend-b0(i))/(b1(i)-slope_mXXend);
       end
            
       new_Rmi = exp(lRmi);
       lmmi = b0(i)+b1(i)*lRmi;
       new_mmi = exp(lmmi);
       
       
       
       %midslope = mean([slope_mXXend,b0(i)]);
       
       
       
       %cp = [2*mr-real_mi(i) , Rmr(i)
       %	       real_mi(i)    , Rmr(i) 
       %	     3*real_mi(i)    ,  exp((log(3*real_mi(i))-b0(i))/b1(i))];
      
       % maybe I should do all these with logs!!
       %cp = [2*mr-new_mmi , 2*Rmr(i) - new_Rmi 
       %      new_mmi   , new_Rmi 
       %      3*new_mmi   , exp((log(3*new_mmi)-b0(i))/b1(i))];
       
       cp = [2*log(mr)-lmmi , 2*log(Rmr(i)) - lRmi 
	     lmmi   , lRmi 
	     3*lmmi   , (3*lmmi-b0(i))/b1(i)];
       
       % if you use k=2 instead of 3, you will get the controlling
       % polygon. If you use higher k's then the curve no longer
       % touches the controlling polygon. whit k=2 you get same
       % results as with "case 0" above.
       k=3;
       % the control polygon stops at 3*mi, so points will be
       % produced up to 2*mi? At least that is where the filleting
       % spline should touch the secant (smoothly)
       newc =  spcrv(cp',k,2*N);
       
       newc=exp(newc);
       
       % sometimes, when mf is very close to mc or mr,
       % the spline fitting will not generate any points within
       % the interval (mc,mf) or (mr,mf). The trick is to get
       % the closest point that spcrv generates plus the point
       % AT mc or mr and linearly interpolate (although adding
       % the flatline there should be ok in most cases! 
       indy = find(newc(1,:)>mr & newc(1,:)<=mf);  
       
       %keyboard
       
       
       % add some more points along the "secant" if mf is larger
       % than the filleting length. The filleting is supposed to
       % stop at the midpoint of the last segment, so about
       % mu=2*mi. Actually, now with the new fitting it is
       % exp(3*lmmi-lmmi)=new_mmi^2
       
       
       if mf > new_mmi^2
	 m_rXX = linspace(new_mmi^2,mf,N+1);
	 m_rXX = m_rXX';
	 R_rXX = exp((log(m_rXX)-b0(i))/b1(i));
       else
	 % add a "flatline point" right on mf. The filleting will
         % never do that by default, so make sure it happens!
	 m_rXX = mf; 
	 if isempty(indy)
	   % then probably mr slightly less than mf (could be just
           % round-off error sometimes). Then just interpolate
           % between the closest values surrounding "mr" (or "mf" 
	   % they are actually the same values since mr,mf are so close).
	   i1=max(find(newc(1,:)<=mr));
	   i2=i1+1;
	 else
	   if indy(end)==length(newc(1,:))
	     % a linear extrapolation. Just so that you get a point
	     % right on the "mf" and capacity gets displayed
	     % correctly. Ahhh, finesse!!
	     i1=indy(end-1);
	     i2=indy(end);
	   else
	     % why extrapolate? Better to interpolate between indy(end)
	     % and the indy(end)+1 point (if it has been calculated).
	     i1=indy(end);
	     i2=indy(end)+1;
	   end 
	 end  
	 R_rXX = newc(2,i2)+(newc(2,i2)-newc(2,i1))/...
		 (newc(1,i2)-newc(1,i1))*(mf-newc(1,i2));
       end	 
       
       idac(i).m=[idac(i).m ; newc(1,indy)' ; m_rXX];
       idac(i).r=[idac(i).r ; newc(2,indy)' ; R_rXX];
	
       % the results are truly excellent.
       
       
     end 
   end   
end