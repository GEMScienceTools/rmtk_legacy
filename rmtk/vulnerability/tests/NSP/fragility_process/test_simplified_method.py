# -*- coding: utf-8 -*-
# <nbformat>3.0</nbformat>

# <codecell>

"""
Created on Tue May 13 18:04:57 2014

@author: chiaracasotto
"""
# Clear existing variables
def clearall():
    all = [var for var in globals() if var[0] != "_"]
    for var in all:
        del globals()[var]
clearall()

# Import functions
import matplotlib.pyplot as plt
import numpy as np
import scipy.stats as stat
import os

pi = 3.141592653589793
plt.close("all")
cd = os.getcwd()

# <codecell>

N = 10
MC = 25
Tc = 0.5
Td = 1.8
plotflag = [1, 1, 1, 1]
linew = 2
fontsize = 10
units = ['[m]', '[kN]', '[g]']
vuln = 0
g = 9.81
iml = np.linspace(0.01,2,100)
an_type = 0
in_type = 1

# <codecell>

Gamma = [1.292]
T = [1.612]
Tav = [1.612]
Sa_ratios = 1
SPO =[[0.036765262,	0.290448402,	2133.26]]
dcroof = [[0.04,	0.07,	0.09,	0.13,	0.3]]
noBlg = 0
w = 1
bUthd = [[0.1,	0.1,	0.1,	0.1,	0.1]]
print "T =", T
print "G =", Gamma
print "w =", w
print "SPO ", SPO
print "dcroof = ", dcroof
print "bUthd = ", bUthd

# <codecell>

T, Gamma, dcroof, SPO, bUthd = T[0], Gamma[0], dcroof[0], SPO[0], bUthd[0]

# <codecell>

if T<0.15: print 'error: T must be larger than 0.15sec'
if T>3: print 'T>3 is not advised, but let us proceed'
# Step 1: Ductility level mu for each Limit State
dy, du = SPO[0],SPO[-2]
dcroof, bUthd = np.array(dcroof),np.array(bUthd)
dcroof[dcroof>du] = du
mcroof = np.divide(dcroof,dy)
print "mu(LS) = ", mcroof
    
Say=4*np.power(pi,2)*dy/(g*Gamma*np.power(T,2));    
c = np.multiply(79.12,np.power(T,1.98))
R50 = 0.5*(1-c+np.sqrt(np.power(c,2)+c*2*(2*mcroof-1)+1))  
if R50.any>6: print 'warning: R > 6 not advised, proceeding anyway'

# <codecell>

# Monte Carlo simulation
st = (1./(2.*MC))
en = (1.-(1./(2.*MC)))
xp = np.linspace(st,en,MC)
musample = []
for i in range(0,len(mcroof)):
    if bUthd[i]>0 and MC>0:
        musample.append(stat.lognorm.ppf(xp,bUthd[i],loc=0,scale=mcroof[i]))
        musample[i][musample[i]>mcroof[-1]]=mcroof[-1]
    else:
        musample.append(np.repeat(mcroof[i],MC))
Nr=10;
R = np.array([np.insert(np.linspace(1,2*ele,Nr),0,0) for ele in R50])
#Define constant relative strength inelastic displacement ratio Cr    
CR50i = 1 + np.divide(R-1,(79.12*np.power(T,1.98)));
bCR50i=1.957*(1/5.876+1/(11.749*(T+0.1)))*(1-np.exp(-0.739*(R-1)));
mu50=R*CR50i;
mu16=mu50*np.exp(-bCR50i);
mu84=mu50*np.exp(bCR50i);
x=[mu16, mu50, mu84];

# <codecell>

Sai = []
for i in range(0,len(mcroof)):
    Sai.append([])
rMC, SaT50, bTSa, Sa = [],[],[],[]

# Estimate R-values of Sa50 and bRSa that correspond to mlim samples.    
for i in range(0,len(mcroof)):
    Sa.append(np.array([]))
    SaT50.append([])
    bTSa.append([])
    rMC.append([np.interp(musample[i],ele[i],R[i]) for ele in x])
    if bUthd[i]>0:
        allSa50 = [ele*Say for ele in rMC[i][1]]
        allbSa50 = (np.log(rMC[i][0])-np.log(rMC[i][2]))/2
        for j in range(0,MC):
                if allbSa50[j]>0:
                    realisation = stat.lognorm.ppf(xp,allbSa50[j],loc=0,scale=allSa50[j])
                else:
                    realisation = np.repeat(allSa50[j],MC)
                Sai[i].append(realisation)

# <codecell>

for i in range(0,len(mcroof)):
    if len(Sai[i])>0:
        for j in range(1,len(Sai[i])):
            Sai[i][j] = np.concatenate((Sai[i][j-1],Sai[i][j]))
        Sa[i] = Sai[i][-1]
        
        SaT50[i] = np.median(Sa[i])
        bTSa[i] = np.std(np.log(Sa[i]))
    else:
        R = np.maximum(0.85*R50[i],1.00001)
        Cr50 = 1+np.divide(R-1,c)
        b = 1+np.divide(np.log(Cr50),np.log(R))
        bthd = 1.957*(1/5.876+1/(11.749*(T+0.1)))*(1-np.exp(-0.73*(R-1)))
        
        SaT50[i] = np.divide(np.power(2*pi/T,2),g*Gamma*Cr50)*dcroof[i]
        bTSa[i] = bthd/b

# <codecell>

print SaT50
print bTSa

# <codecell>


