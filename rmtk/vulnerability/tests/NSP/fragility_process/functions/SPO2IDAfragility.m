function [SaR50,bRSa,SaT50,bTSa]=SPO2IDAfragility(dy,dlim,buthd,mc,a,ac,r,mf,T,Gamma,g,N)
% Estimate fragility parameters for an MDOF system approximated by an equivalent
% SDOF and using SPO2IDA by Vamvatsikos & Cornell (2005).
%____________________________________________________________________________
% INPUT
% Cy     : base shear coefficient at yield (presently covered by Gamma and dy)
%          Cy = Say/g = Vy/W, where Say=Sa @ yield, Vy = base shear @ yield
% dlim  : median roof displacement value that defines the fragility. It can result 
%          from any EDP but it should be expressed in terms of the (median)
%          corresponding roof disp (just like we always do in pushovers anyway)
% dy    : roof yield displacement
% buthd  : dispersion (std of log data) characterizing the lognormal
%          distribution of "limit-state roof drift capacity" around dlim
% mc,a,ac,r,mf : the backbone shape parameters for SPO2IDA 
% T      : ESDOF period (sec)
% Gamma  : the participation factor for the roof displacement(>1) 
% g      : the value of "g" in units compatible with T and dlim, dy.
%          The default is 9.81m/s2, assuming that dy and dlim are in meters.
% N      : Number of realizations to use for Monte Carlo when buthd>0 to
%          incorporate extra uncertainty due to a non-deterministic dlim
%          threshold 
% OUTPUT
% SaR50  : the median Sa for the fragility, in units of "g", considering only
%           record-to-record variability
% bRSa   : the dispersion due to record-to-record variability (i.e. demand only)
% SaR50  : the median Sa for the fragility, in units of "g", considering both
%          capacity and demand dispersions
% bTSa   : the total dispersion, including capacity and demand dispersions.
%_____________________________________________________________________________
%
% CREATED 11/June/2014 by D.Vamvatsikos
% Updated 16/Dec/2014: Added more explanatory comments in the MC procedure.
% Updated 24/Dec/2014: Added minor modifications in the estimation of bTSa,
%         SaT50 to make sure they return bRSa,SaR50 when buthd=0. Earlier
%         versions would terminate with an error. Also added a check when doing
%         the Monte Carlo for adding epistemic uncertainty to make sure that a
%         very low EDPlim, practically less than a mu=1, would not create zero
%         dispersions and thus a bTSa=NaN in the end.
% 
% Example
% T=0.4; Gamma=1.2; 
% a=0.10, ac=-0.5, mc=4, r=0, mf=6 
% dlim=0.15; dy=0.05; %(in meters)
% buthd=0.25;
% [SaR50,bRSa,SaT50,bTSa]=SPO2IDAfragility(dy,dlim,buthd,mc,a,ac,r,mf,T,Gamma)

if nargin<12, N=25; end
if nargin<11, g=9.81; end
if nargin<10, error('need at least 10 arguments'); end

%plotflag=1;
plotflag=0;

% Get SPO2IDA results
[spoc,idac,cap]=spo2ida_allT(mc,a,ac,r,mf,T);

% limiting ductility that defines fragility
mlim=min(dlim/dy,mf);
% Assume lognormal and do some Monte Carlo on potential values of mlim,
% according to the supplied buthd
if buthd>0
   xp=linspace( 1./(2*N),1-1./(2*N), N);
   musample=logninv(xp,log(mlim),buthd);
   % any mlim that exceeds mf should obviously produce the same results as mf,
   % so take it down to mf to avoid complaints for extrapolation later.
   musample(musample>mf)=mf;
end

if plotflag && buthd>0
   figure(1);clf;hold on
end

for j=1:3
   [x,indx]=unique(idac(j).m);
   y=idac(j).r(indx);
   rM(j)=interp1(x,y,mlim);
   if buthd>0
      % Estimate R-values on each fractile that correspond to mlim samples.
      rMC(j,:)=interp1(x,y,musample);
   end
   if plotflag
      plot(x,y,'b-')
      % show all the sampled values for mlim on the plot for each fractile IDA
      plot(musample,rMC(j,:),'ro')
   end
end


      
Say=4*pi^2*dy./(g*Gamma.*T.^2);
SaR50=rM(2)*Say;
bRSa=0.5*(log(rM(1))-log(rM(3)));


if buthd>0
   % these are simple estimates of relatively good accuracy. Remember, rMC contains
   % the R-values that correspond to mlim samples for each fractile IDA.
   SaT50_0=median(rMC(2,:))*Say;
   bTSa_0=sqrt(bRSa^2+std(log(rMC(2,:)))^2);
   
   Sai=zeros(1,N*N);
   % this is to compute the better estimate, still it is much different from above
   % estimates (at least for most cases that I have tried).
   allSa50=rMC(2,:)*Say;
   allbSa50=0.5*(log(rMC(1,:))-log(rMC(3,:)));
   for i=1:N
      % for each potential (equiprobable) sample of mlim, get a sample of
      % Sa-values as if we actually had N separate IDA curves, distributed
      % according to the Sa50 and bSa50 values extracted above. In other words,
      % generate N Sa-capacities for N different mlim realizations.
      if allbSa50(i)>0
         Sai((i-1)*N+1:i*N)=logninv(xp,log(allSa50(i)),allbSa50(i));
      else
         % no dispersion, set the values equal to the median. Unfortunately,
         % logninv would produce a NaN.
         Sai((i-1)*N+1:i*N)=allSa50(i);
      end
   end

   % Get the median and stdlog values of the entire sample of Sa capacities
   SaT50=median(Sai);
   bTSa=std(log(Sai));
else
   SaT50=SaR50;
   bTSa=bRSa;
end

