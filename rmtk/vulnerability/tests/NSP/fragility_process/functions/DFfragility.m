function [Sa50,bTSa]=DFfragility(dy,dlim,buthd,mc,r,T,Gamma,du,Tc,Td,g,N)
% Estimate fragility parameters for an MDOF system approximated by an equivalent
% SDOF and using the R-mu-T relationships of Dolsek & Fajfar 2004 paper 
% (Earthquake Engng Struct. Dyn. 2004; 33:1395–1416). Some application details
% and defaults are taken from Dolsek & Fajfar 2005 paper (Earthquake Engng
% Struct. Dyn. 2005; 34:49–66). Dispersion results are not provided and thus
% taken from Ruiz-Garcia & Miranda, assuming elastoplastic backbone. This
% probably underestimates dispersion beyond the capping point, but that is the
% best we can do without going to SPO2IDA. Original D&F paper suggested cov=0.7
% in short period range and 0.4 for medium/long but this is too coarse for our
% needs.
%
% This R-mu-T is suggested by the authors as conservative, since it is
% not based on the median but on the mean mu given R. It is also based on
% Newmark-Hall type spectra. In the following I will try to correct it assuming
% lognormality and the dispersion of Ruiz-Garcia & Miranda (2007). 
%
% Shape of the backbone is elastic-plastic-negative-residual. 
% Parameters
% Dolsek <=> SPO2IDA
%     ms <=> mc (capping point, i.e., end-of-plastic-plateau, ductility)
%     mu <=> mr (end-of-negative-stiffness ductility, ignored by the model)
%     ru <=> rp (residual strength, normalized by the yield strength)
%____________________________________________________________________________
% INPUT
% Cy     : base shear coefficient at yield (presently covered by Gamma and dy)
%          Cy = Say/g = Vy/W, where Say=Sa @ yield, Vy = base shear @ yield
% dlim  : median roof displacement value that defines the fragility. It can result 
%          from any EDP but it should be expressed in terms of the (median)
%          corresponding roof disp (just like we always do in pushovers anyway)
% dy    : roof yield displacement
% buthd  : dispersion (std of log data) characterizing the lognormal
%          distribution of "limit-state roof drift capacity" around dlim
% T      : ESDOF period (sec)
% Gamma  : the participation factor for the roof displacement(>1). Note that for
%          a tall building (or higher-mode influenced one) it is best if you get
%          this value from Say versus droofy estimated from modal response
%          spectrum analysis to include multiple modes. If you use the Gamma of
%          the first one only you will not do well enough (it tends to be
%          lower). See work of Katsanos & Vamva (2014). 
% du    : ultimate displacement on the backbone.
% Tc,Td  : constant accel-constant velocity  and constant velocity-constant
%          displacement corner periods of a Newmark-Hall type spectrum. Default
%          values (roughly taken from Dolsek & Fafjar's (2005) third set of
%          ground motions), are [0.5,1.8].
% mc     : end-of-plastic-plateau capping ductility.
% r      : residual plateau strength divided by yield strength
%
% g      : the value of "g" in units compatible with T and dlim, dy.
%          The default is 9.81m/s2, assuming that dy and dlim are in meters.
% N      : Number of realizations to use for Monte Carlo when buthd>0 to
%          incorporate extra uncertainty due to a non-deterministic dlim
%          threshold. If N=0 is provided, a simpler approximation is used
%          instead that is not based on Monte Carlo but on closed form
%          expressions.
% OUTPUT
% Sa50   : the median Sa for the fragility, in units of "g"
% bTSa   : the total dispersion, including capacity and demand dispersions.
% bRSa   : the dispersion due to record-to-record variability (i.e. demand only)
%_____________________________________________________________________________
%
% Created 07/Sep/2014 by D.Vamvatsikos
% Updated 25/Dec/2014: Added du as an optional ultimate displacement. Helps a
%         lot to limit large dlim values. Also fixed a minor error where I was
%         checking for the input of Td and then I was defining Tc and
%         vice-versa. Added the MC method for introducing dlim uncertainty and
%         fixed the approximate approach by making sure the uncertainty is not
%         included if dlim exceeds du (i.e., we are in the collapse range).
% NOTES
% If you set a dlim close but lower than du, the ultimate displacement, this
% will correctly influence the results if you use the MC method. Otherwise, you
% will see a difference only when dlim<du and dlim>du. In the first case, we
% include buthd while in the latter we do not. Clearly an approximation.
% 
% EXAMPLE
% T=1; Gamma=1.3; 
% dlim=0.35; dy=0.1; du=0.4; %(in meters)
% buthd=0.2;
% mc=2; r=0.5;
% %Estimate with MC, 
% [Sa50,bTSa]=DFfragility(dy,dlim,buthd,mc,r,T,Gamma,du)
% %Estimate without MC
% [Sa50,bTSa]=DFfragility(dy,dlim,buthd,mc,r,T,Gamma,du,[],[],[],0)

if nargin<12, N=25; end
if nargin<11||isempty(g), g=9.81; end
if nargin<10||isempty(Td), Td=1.8; end
if nargin<9||isempty(Tc), Tc=0.5; end
if nargin<8||isempty(du), du=Inf; end
if nargin<7, error('need at least 7 arguments'); end
if r>1, error('rp should be lower than 1.0'); end
if r<0.25, warning('rp should be higher than 0.25, but let us proceed'); end
if mc<1, error('mc should be higher than 1.0'); end
if mc>2.5, warning('mc should be lower than 2.5, but let us proceed'); end


% set plotflag=1 for visual help with debugging
plotflag=1;

% median roof displacement value for defining fragility is higher than the
% ultimate one. Replace it by the ultimate (they will both correspond to
% collapse so it makes sense). Still, keep a flag to signify this change as in
% such cases you had better not include buthd in the fragility of collapse 
% if using the approximate method. MC will take care of it automatically!
if dlim>du
   noUncApproxflag=1;
   dlim=du;
else
   noUncApproxflag=0;
end

mlim=dlim/dy;

% From the graphs the authors do not show data for mean ductilities larger 
% than 10 (Fig. 14b). Let's adopt a maximum for the mean ductility of 10.
% For now, let's implement this as a warning. 
if mlim>10, warning('mlim should best be less than 10, but let us proceed'); end 


% For a given period, the IDA model is bilinear (piecewise linear with 2 
% segments)in the post-yield range. 
% In other words it provides a trilinear approximation for the mean IDA (mean mu
% given R). The point where this change happens is [mc,Rmc].
% So the mean IDA is defined by 4 points total and 3 segments (incl. elastic):
% Elastic segment: [0,0] -> [1,1]  
%                  Note though the improvement suggested in D&F (2006) that is
%                  not adopted here.
% Capping segment: [1,1] -> [mc,Rmc]
% Post-capping   : [mc,Rmc] -> [mf,Rmf]
%                  where the final point is selected by some arbitrary
%                  Rmf>Rmc, mf=function of Rmf.
% Thus, to get the mean IDA, I only need mf and Rmf (in addition to mc,Rmc).


% Get the (mc50, Rmc) point
Tdstar=Td*sqrt(2-r);
if T<=Tc
   Rmc=0.7*(T/Tc)*(mc-1)+1;
elseif T<=Tdstar
   DT=(T-Tc)/(Tdstar-Tc);
   Rmc=(0.7+0.3*DT)*(mc-1)+1;
else
   Rmc=mc;
end

% RGM2007 was fit up to an R=6. Find the largest beta for this period given
% that R=6 and make sure you do not exceed it.
R6=6;
bthd_max=1.957*(1/5.876+1./(11.749*(T+0.1))).*(1-exp(-0.739*(R6-1)));

% find the capping point on the IDA curve.
if Rmc<=R6
   bthd_mc=1.957*(1/5.876+1./(11.749*(T+0.1))).*(1-exp(-0.739*(Rmc-1)));
else
   % too large Rmc, cap its dispersion by the max fitted by RGM2007
   bthd_mc=bthd_max;
end
mc50=mc/exp(0.5*bthd_mc^2);
mc16=mc50*exp(-bthd_mc);
mc84=mc50*exp(bthd_mc);

% Now set Rmf as twice Rmc and get [mf50,Rmf]. No real reason why I am using
% double the value, but since the approximation is linear here, I can
% interpolate or extrapolate as needed and be fine, so the actual value of Rmf
% does not matter, as long as the slope Rmf/mf is right!
% Actually it matters only in terms of beta. Since I am also using a bilinear
% aproximation for the 16/84% fractiles and I am estimating beta at the Rmf
% point for the post-capping part of those, it may make a bit of difference.
% Still, RGM2007 employs an approximation based exp(-a*(R-1)) that goes to a
% value of 1.0, and thus a constant value of bthd, very quickly. The general
% premise of the DF2004 approximation based on trilinear IDAs is not helping a
% lot here (e.g., I cannot maintain a constant dispersion beyond a certain R or
% mu, e.g. R=6 as I would like).


Rmf=max([2*Rmc,6]);

%if Rmf<=Rmc
%   R0=1;
%   m0=1;
%else
   R0=Rmc;
   m0=mc;
%end

% R<Rmc will never happen here, thus the commented out parts
if T<=Tc
   %if Rmf<=Rmc
   %   c=0.7*T/Tc;
   %else
      c=0.7*sqrt(r)*(T/Tc)^(1/sqrt(r));
   %end
elseif T<=Tdstar
   %if Rmf<=Rmc
   %   c=0.7+0.3*DT;
   %else
      c=0.7*sqrt(r)*(1-DT)+DT;
   %end
else
   c=1;
end



% This is the mean mu given R at the ficticious Rmf point used to define the
% post-capping segment.
mf_mean=(Rmf-R0)/c + m0;
bthd_mf=bthd_max;

% For lognormal: Median = mean * exp(0.5*sigma^2)
mf50=mf_mean/exp(0.5*bthd_mf^2);
mf16=mf50*exp(-bthd_mf);
mf84=mf50*exp(bthd_mf);

R=[0,1,Rmc,Rmf];
mu16=[0,1,mc16,mf16];
mu50=[0,1,mc50,mf50];
mu84=[0,1,mc84,mf84];
if plotflag
   figure(1);clf;hold on
   plot(mu16,R,mu50,R,mu84,R); grid on
end

% Now we have fractiles and can invert. Use linear extrapolation for mlim values
% larger than mf. 
R16=interp1(mu84,R,mlim,'linear','extrap');
R50=interp1(mu50,R,mlim,'linear','extrap');
R84=interp1(mu16,R,mlim,'linear','extrap');

% The SA value at yield
Say=4*pi^2*dy./(g*Gamma.*T.^2);



if buthd>0 && N>0
   % Monte Carlo approach
   xp=linspace( 1./(2*N),1-1./(2*N), N);
   musample=logninv(xp,log(mlim),buthd);
   % any mlim that exceeds mf should obviously produce the same results as mf,
   % so take it down to mf to avoid complaints for extrapolation later.
   muf=du/dy;
   musample(musample>muf)=muf;
   % Estimate R-values of Sa50 and bRSa that correspond to mlim samples.
   x=[mu16;mu50;mu84];
   for j=1:3
      rMC(j,:)=interp1(x(j,:),R,musample,'linear','extrap');
      if plotflag
         %show all the sampled values for mlim on the plot for each fractile IDA
         plot(musample,rMC(j,:),'ro')
      end
   end
   % these are simple estimates of relatively good accuracy. Remember, rMC contains
   % the R-values that correspond to mlim samples for each fractile IDA.
   
   
   Sai=zeros(1,N*N);
   % this is to compute the better estimate, still it is much different from above
   % estimates (at least for most cases that I have tried).
   allSa50=rMC(2,:)*Say;
   allbSa50=0.5*(log(rMC(1,:))-log(rMC(3,:)));
   for i=1:N
      % for each potential (equiprobable) sample of mlim, get a sample of
      % Sa-values as if we actually had N separate IDA curves, distributed
      % according to the Sa50 and bSa50 values extracted above. In other words,
      % generate N Sa-capacities for N different mlim realizations.
      if allbSa50(i)>0
         Sai((i-1)*N+1:i*N)=logninv(xp,log(allSa50(i)),allbSa50(i));
      else
         % no dispersion, set the values equal to the median. Unfortunately,
         % logninv would produce a NaN.
         Sai((i-1)*N+1:i*N)=allSa50(i);
      end
   end

   % Get the median and stdlog values of the entire sample of Sa capacities
   Sa50=median(Sai);
   bTSa=std(log(Sai));
else
   % Simplified approach.
   % Go to an R value at 85% of the R50 for a biased estimate of "b", the local
   % slope in log-log of the median IDA.
   Rlim=0.85*R50;
   m50Rlim=interp1(R,mu50,Rlim,'linear','extrap');
   b=log(m50Rlim)/log(Rlim);
   CR50 = mlim/R50;
   Sa50 = 4*pi^2*dlim./(g*Gamma.*CR50.*T.^2);
   bRSa=0.5*(log(R84)-log(R16));
   bUSa=buthd/b;
   if noUncApproxflag
      % dlim was greater than du. In such cases it makes little sense to
      % include the dispersion of dlim in the total dispersion. The reason is
      % that we are already at collapse, so changes in dlim have no effect at
      % all. The MC approach takes care of this automatically. Obviously this
      % remains a rough binary approximation (include / don't include) for dlim
      % values close to du. 
      bTSa = bRSa;
   else
      bTSa = sqrt(bUSa.^2 + bRSa.^2);
   end
end



